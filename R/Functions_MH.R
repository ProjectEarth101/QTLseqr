#' @import grDevices
#' @import graphics
#' @import stats
#' @import utils

globalVariables(c("read.vcfR","vcfR2tidy","rbindlist","select","CHROM","POS","DP","QUAL","ggplot","aes","geom_point","nSNPs","facet_wrap","geom_smooth","theme_bw","labs","scale_color_manual","geom_histogram","theme_classic","chart.Correlation","AD_REF.LOW","AD_REF.HIGH","rcorr","RO","AO","AC","DPB","QA","AD_ALT.LOW","AD_ALT.HIGH","LowRef","HighRef","LowAlt","HighAlt","nSNPs","vars","SNPSet.AD_ALT.HIGH","SNPSet.AD_REF.HIGH","SNPSet.AD_REF.LOW","SNPSet.AD_ALT.LOW","desc","labs","drop_na","DP.HIGH","DP.LOW","GQ.LOW","GQ.HIGH","tricubeDeltaSNP","passThresh","qvalue","Gprime","pvalue","SNPindex.LOW","SNPindex.HIGH","extract_gt_tidy","importFromVCF","Indiv","LowBulk","HighBulk","obs_MH","ggscatter","stat_cor","ggscatterhist","deltaSNP","G","h","geom_line","corrplot","facet_grid","arrange","AD.LOW","AD.HIGH","mutate",".","Key","SNPset.AD_ALT.HIGH","SNPset.AD_ALT.LOW","SNPset.AD_REF.HIGH","SNPset.AD_REF.LOW","theme_minimal","value","Interval","value","getG_MH","minDP"))


# Function Parses a VCF file generated by freebayes filtering process
# Function Parses a VCF file generated by freebayes filtering process
# Function
#' @title QTLParser_1_MH
#' @description Parses a vcf file which has been converted to a tidy data frame before running the operation
#' @param vcf A vcf file that is as a tidy data frame
#' @param HighBulk The name of the HighBulk sample
#' @param LowBulk The name of the LowBulk sample
#' @param filename Provide a partiular name to identify input CSV file
#' @export QTLParser_1_MH

QTLParser_1_MH<-
  function (vcf, HighBulk, LowBulk, filename)
  {
    CHROM <- vcf$fix$CHROM
    POS <- vcf$fix$POS
    REF <- vcf$fix$REF
    ALT <- vcf$fix$ALT
    DP <- vcf$gt$gt_DP
    Samples <- vcf$gt$Indiv
    AD <- vcf$gt$gt_AD
    Data <- data.frame(AD, Samples)
    var1 <- AD[(as.matrix(Data[2] == HighBulk))]
    Data <- data.frame(CHROM, POS, REF, ALT, DP, var1, Samples)
    Data <- Data %>% drop_na(var1)
    var2 <- Data$var1
    var <- unlist(strsplit(var2, ","))
    len <- length(var)
    seq <- seq(1, len, 2)
    AD_REF. <- var[c(seq)]
    seq2 <- seq(2, len, 2)
    AD_ALT. <- var[c(seq2)]
    Data$AD_REF. <- AD_REF.
    Data$AD_ALT. <- AD_ALT.
    Data <- Data[, -6]
    Data <- Data[!rowSums(nchar(as.matrix(Data[3])) != 1), ]
    Data <- Data[!rowSums(nchar(as.matrix(Data[4])) != 1), ]
    Data <- Data[(as.matrix(Data[6]) == HighBulk), ]
    Data <- Data[, -6]
    write.table(Data, file = paste0(HighBulk, ".tsv"), row.names = FALSE,
                col.names = TRUE, sep = "\t", quote = FALSE)
    write.table(Data, file = paste0(HighBulk, ".csv"), row.names = FALSE,
                col.names = TRUE, sep = ",", quote = FALSE)
    CHROM <- vcf$fix$CHROM
    POS <- vcf$fix$POS
    REF <- vcf$fix$REF
    ALT <- vcf$fix$ALT
    DP <- vcf$gt$gt_DP
    Samples <- vcf$gt$Indiv
    AD <- vcf$gt$gt_AD
    Data <- data.frame(AD, Samples)
    var1 <- AD[(as.matrix(Data[2] == LowBulk))]
    Data <- data.frame(CHROM, POS, REF, ALT, DP, var1, Samples)
    Data <- Data %>% drop_na(var1)
    var2 <- Data$var1
    var <- unlist(strsplit(var2, ","))
    len <- length(var)
    seq <- seq(1, len, 2)
    AD_REF. <- var[c(seq)]
    seq2 <- seq(2, len, 2)
    AD_ALT. <- var[c(seq2)]
    Data$AD_REF. <- AD_REF.
    Data$AD_ALT. <- AD_ALT.
    Data <- Data[, -6]
    Data <- Data[!rowSums(nchar(as.matrix(Data[3])) != 1), ]
    Data <- Data[!rowSums(nchar(as.matrix(Data[4])) != 1), ]
    Data <- Data[(as.matrix(Data[6]) == LowBulk), ]
    Data <- Data[, -6]
    write.table(Data, file = paste0(LowBulk, ".tsv"), row.names = FALSE,
                col.names = TRUE, sep = "\t", quote = FALSE)
    write.table(Data, file = paste0(LowBulk, ".csv"), row.names = FALSE,
                col.names = TRUE, sep = ",", quote = FALSE)
    df1 <- read.csv(file = paste0(HighBulk, ".csv"), header = TRUE)
    df2 <- read.csv(file = paste0(LowBulk, ".csv"), header = TRUE)
    df3 <- merge(df1, df2, by = c("CHROM", "POS", "REF", "ALT"),
                 all.x = TRUE)
    names(df3)[5] <- paste0("DP.", HighBulk)
    names(df3)[6] <- paste0("AD_REF.", HighBulk)
    names(df3)[7] <- paste0("AD_ALT.", HighBulk)
    names(df3)[8] <- paste0("DP.", LowBulk)
    names(df3)[9] <- paste0("AD_REF.", LowBulk)
    names(df3)[5] <- paste0("DP.", HighBulk)
    names(df3)[6] <- paste0("AD_REF.", HighBulk)
    names(df3)[7] <- paste0("AD_ALT.", HighBulk)
    names(df3)[8] <- paste0("DP.", LowBulk)
    names(df3)[9] <- paste0("AD_REF.", LowBulk)
    names(df3)[10] <- paste0("AD_ALT.", LowBulk)
    df3 <- na.omit(df3, c(paste0("AD_REF.", HighBulk), paste0("AD_ALT.",
                                                              HighBulk), paste0("DP.", HighBulk), paste0("DP.", LowBulk),
                          paste0("AD_REF.", LowBulk), paste0("AD_ALT.", LowBulk)))
    write.table(df3, file = paste0(filename,".csv"), row.names = FALSE, col.names = TRUE, sep = ",")

    return(unique(vcf$fix$CHROM))
}



#' @title runGprimeAnalysis_GPrime_Smooth
#' @description Runs a Gprime Analysis on Bulk segregants with additional smoothing parameters for G Prime Test Statistic
#' @param SNPset An SNPset
#' @param windowSize Specify the WindowSize
#' @param outlierFilter Specify the outlierFilter
#' @param filterThreshold Specify threshold filter value default is 0.1
#' @param deg Degree of Polynomial to use for LocFit Model
#' @param nn Nearest Neighbor component of smoothing parameter. Default value is 0.7, unless h or adpen are provided, in which case the default is 0
#' @export runGprimeAnalysis_GPrime_Smooth


runGprimeAnalysis_GPrime_Smooth <-
  function (SNPset, windowSize = windowSize, outlierFilter = "deltaSNP",
            filterThreshold = 0.1, deg = deg, nn = nn)
  {
    message("Counting SNPs in each window...")
    SNPset <- SNPset %>% dplyr::group_by(CHROM) %>% dplyr::mutate(nSNPs = countSNPs_cpp(POS = POS, windowSize = windowSize))
    message("Calculating tricube smoothed delta SNP index...")
    SNPset <- SNPset %>% dplyr::mutate(tricubeDeltaSNP = tricubeStat(POS = POS, Stat = deltaSNP, windowSize))
    message("Calculating G and G' statistics...")
    SNPset <- SNPset %>% dplyr::mutate(G = getG_MH(LowRef = AD_REF.LOW, HighRef = AD_REF.HIGH, LowAlt = AD_ALT.LOW, HighAlt = AD_ALT.HIGH), Gprime = tricube_Smooth(POS = POS, Stat = G, windowSize = windowSize, deg = deg, nn = nn)) %>% dplyr::ungroup() %>% dplyr::mutate(pvalue = getPvals_MH(Gprime = Gprime, deltaSNP = deltaSNP, outlierFilter = outlierFilter, filterThreshold = filterThreshold), negLog10Pval = -log10(pvalue), qvalue = p.adjust(p = pvalue, method = "BH"))
    return(as.data.frame(SNPset))
  }


#' @title tricube_Smooth
#' @description Applies Tricube Kernel to G Test Statistic
#' @param POS THe Position vector of where the SNPs were called
#' @param Stat The G Statistic, however, it is the G~lp(x) for a local regression and likelihood model
#' @param windowSize Specify the WindowSize
#' @param deg Degree of Polynomial to use for LocFit Model
#' @param nn Nearest Neighbor component of smoothing parameter. Default value is 0.7, unless h or adpen are provided, in which case the default is 0
#' @export tricube_Smooth




tricube_Smooth <-
  function (POS, Stat, windowSize, deg, nn)
  {
    if (windowSize <= 0)
      stop("A positive smoothing window is required")
    stats::predict(locfit::locfit(Stat ~ locfit::lp(POS, windowSize = windowSize,
                                                    deg = deg, nn = nn)), POS)
  }




#' @title getPvals_MH
#' @description Calculates/Returns pvalues
#' @param Gprime G Prime Statistic
#' @param deltaSNP Default is NULL
#' @param outlierFilter Choose outlier filtering method Either deltaSNP or Hampel
#' @param filterThreshold Choose filter threshold value should be less than 0.5
#' @export getPvals_MH

getPvals_MH <-
  function(Gprime,
           deltaSNP = NULL,
           outlierFilter = c("deltaSNP", "Hampel"),
           filterThreshold)
  {

    if (outlierFilter == "deltaSNP") {

      if (abs(filterThreshold) >= 0.5) {
        stop("filterThreshold should be less than 0.5")
      }

      message("Using deltaSNP-index to filter outlier regions with a threshold of ", filterThreshold)
      trimGprime <- Gprime[abs(deltaSNP) < abs(filterThreshold)]
      #The next line is what I edited from the original getPvals
      #I added the next line to remove by some glitch values that were calculated to be NA's
      trimGprime <- trimGprime[!is.na(trimGprime)]
    } else {
      message("Using Hampel's rule to filter outlier regions")
      lnGprime <- log(Gprime)

      medianLogGprime <- median(lnGprime)

      # calculate left median absolute deviation for the trimmed G' prime set
      MAD <-
        median(medianLogGprime - lnGprime[lnGprime <= medianLogGprime])

      # Trim the G prime set to exclude outlier regions (i.e. QTL) using Hampel's rule
      trimGprime <-
        Gprime[lnGprime - median(lnGprime) <= 5.2 * MAD]
    }

    medianTrimGprime <- median(trimGprime)

    # estimate the mode of the trimmed G' prime set using the half-sample method
    message("Estimating the mode of a trimmed G prime set using the 'modeest' package...")
    modeTrimGprime <-
      modeest::mlv(x = trimGprime, bw = 0.5, method = "hsm")[1]

    muE <- log(medianTrimGprime)
    varE <- abs(muE - log(modeTrimGprime))
    #use the log normal distribution to get pvals
    message("Calculating p-values...")
    pval <-
      1 - plnorm(q = Gprime,
                 meanlog = muE,
                 sdlog = sqrt(varE))

    return(pval)
}


#' @title Obs_Allele_Freq
#' @description Returns a 4 column data frame with Chromosome, Position, and Observed allele frequencies from the High Parent for both bulks
#' @param  SNPSet A SNPSet generated from the function importFromTable
#' @param size A scalar which optimal value depends on number of SNPs...
#' @export Obs_Allele_Freq

Obs_Allele_Freq <-
  function (SNPSet,size)
  {
    frame <- SNPSet %>% dplyr::mutate(LowRef = AD_REF.LOW, HighRef = AD_REF.HIGH, LowAlt = AD_ALT.LOW, HighAlt = AD_ALT.HIGH) %>% dplyr::select(CHROM,POS,DP.LOW,DP.HIGH,LowRef, HighRef, LowAlt, HighAlt,nSNPs)
    message("Graphing GGplot")
    e <- ggplot(frame, aes(x = POS)) + geom_line(aes(y = LowAlt/DP.LOW), color = "orange")  + geom_point(aes(y = LowAlt/DP.LOW), color = "orange", size = size*SNPSet$nSNPs) + geom_line(aes(y = HighAlt/DP.HIGH), color = "blue") + geom_point(aes(y = HighAlt/DP.HIGH), color = "blue", size = size*SNPSet$nSNPs) + facet_grid(rows = vars(CHROM))
    print(e)
    #Write a message
    message("Returing Head of Data Frame")
    return(head(frame))
  }


#' @title Obs_Allele_Freq2
#' @description Returns a 4 column data filtering for specific Chromosome and High Bulk Observed Allele Frequencies
#' @param SNPSet A SNPSet generated from the function importFromTable
#' @param ChromosomeValue Input a Specific Chromosome Value
#' @param threshold Input a Specific Allele Frequency Threshold value from the High Bulk High Parent
#' @param pvalueThresh Upper limit on pvalue for Gprime Statistic
#' @export Obs_Allele_Freq2

Obs_Allele_Freq2 <-
  function (SNPSet, ChromosomeValue, threshold, pvalueThresh) 
  {
    frame <- SNPSet %>% dplyr::mutate(LowRef = AD_REF.LOW, HighRef = AD_REF.HIGH, 
                                      LowAlt = AD_ALT.LOW, HighAlt = AD_ALT.HIGH) %>% select(CHROM, 
                                                                                             POS, LowRef, HighRef, LowAlt, HighAlt, pvalue)
    Obs <- seq(from = 1, to = length(frame))
    p1 <- ((frame$LowAlt)/(frame$LowRef + frame$LowAlt))
    p1 <- round(p1, 3)
    p2 <- ((frame$HighAlt)/(frame$HighRef + frame$HighAlt))
    p2 <- round(p2, 3)
    diff <- p2 - p1
    Chrom <- SNPSet %>% dplyr::select(CHROM)
    POS <- SNPSet %>% dplyr::select(POS)
    pvalue <- SNPSet %>% dplyr::select(pvalue)
    AD_High1 <- data.frame(SNPSet$AD_ALT.HIGH, SNPSet$AD_REF.HIGH)
    AD_High1$AD_High <- paste(AD_High1$SNPSet.AD_REF.HIGH, AD_High1$SNPSet.AD_ALT.HIGH, 
                              sep = ",")
    AD_High <- subset(AD_High1, select = -c(SNPSet.AD_ALT.HIGH, 
                                            SNPSet.AD_REF.HIGH))
    AD_Low1 <- data.frame(SNPSet$AD_REF.LOW, SNPSet$AD_ALT.LOW)
    AD_Low1$AD_Low <- paste(AD_Low1$SNPSet.AD_REF.LOW, AD_Low1$SNPSet.AD_ALT.LOW, 
                            sep = ",")
    AD_Low <- subset(AD_Low1, select = -c(SNPSet.AD_REF.LOW, 
                                          SNPSet.AD_ALT.LOW))
    Gprime <- SNPSet %>% select(Gprime)
    Gprime <- round(Gprime, 3)
    REF <- SNPSet$REF
    ALT <- SNPSet$ALT
    Subst <- paste0(REF, "____>", ALT)
    SNP_Observations <- seq(from = 1, to = length(p1), by = 1)
    data <- cbind(Chrom, POS, p1, p2, Subst, diff, AD_High, AD_Low, 
                  Gprime, SNP_Observations, pvalue)
    data <- as.data.frame(data)
    data <- data %>% arrange(desc(Gprime), Chrom, POS, p1, p2, 
                             pvalue, diff, AD_High, AD_Low)
    data <- data[(as.matrix(data[1]) %in% ChromosomeValue), ]
    data <- data[(as.matrix(data[4]) > threshold), ]
    data <- data[(as.matrix(data[11]) < pvalueThresh), ]
    e <- ggplot(data = data, aes(x = SNP_Observations, y = p1)) + 
      geom_point(aes(color = factor(CHROM))) + theme_bw() + 
      labs(x = "SNP", y = "Allele Frequency", title = "Low Bulk Observed High Parent Allele Frequency")
    print(e)
    SNP_Observations <- seq(from = 1, to = length(p2), by = 1)
    data <- cbind(Chrom, POS, p1, p2, Subst, AD_High, AD_Low, 
                  Gprime, SNP_Observations, pvalue)
    data <- as.data.frame(data)
    data <- data %>% arrange(desc(Gprime), Chrom, POS, p1, p2, 
                             pvalue, Subst, AD_High, AD_Low)
    data <- data[(as.matrix(data[1]) %in% ChromosomeValue), ]
    data <- data[(as.matrix(data[4]) > threshold), ]
    data <- data[(as.matrix(data[10]) < pvalueThresh), ]
    e1 <- ggplot(data = data, aes(x = SNP_Observations, y = p2)) + 
      geom_point(aes(color = factor(CHROM))) + 
      theme_bw() + labs(x = "SNP", y = "Allele Frequency", 
                        title = "High Bulk Observed High Parent Allele Frequency")
    print(e1)
    return(data)
  }







#' Plots Gprime distribution
#' Modified by MH
#' Plots a ggplot histogram of the distribution of Gprime with a log normal
#' distribution overlay
#'
#' @param SNPset a data frame with SNPs and genotype fields as imported by
#'   \code{ImportFromGATK} and after running \code{GetPrimeStats}
#' @param outlierFilter one of either "deltaSNP" or "Hampel". Method for
#'   filtering outlier (ie QTL) regions for p-value estimation
#' @param filterThreshold The absolute delta SNP index to use to filter out
#'   putative QTL (default = 0.1)
#' @param binwidth The binwidth for the histogram. Recomended and default = 0.5
#'
#' @return Plots a ggplot histogram of the G' value distribution. The raw data
#'   as well as the filtered G' values (excluding putatitve QTL) are plotted. It
#'   will then overlay an estimated log normal distribution with the same mean
#'   and variance as the null G' distribution. This will allow to verify if
#'   after filtering your G' value appear to be close to log normally and thus
#'   can be used to estimate p-values using the non-parametric estimation method
#'   described in Magwene et al. (2011). Breifly, using the natural log of
#'   Gprime a median absolute deviation (MAD) is calculated. The Gprime set is
#'   trimmed to exclude outlier regions (i.e. QTL) based on Hampel's rule. An
#'   estimation of the mode of the trimmed set is calculated using the
#'   \code{\link[modeest]{mlv}} function from the package modeest. Finally, the
#'   mean and variance of the set are estimated using the median and mode are
#'   estimated and used to plot the log normal distribution.
#' @seealso \code{\link{getPvals}} for how p-values are calculated.
#' @export plotGprimeDist_MH





plotGprimeDist_MH<-
function (SNPset, outlierFilter = c("deltaSNP", "Hampel"), filterThreshold = 0.1,
          binwidth = 0.5)
{
  if (outlierFilter == "deltaSNP") {
    trim_df <- SNPset[abs(SNPset$deltaSNP) < filterThreshold,
    ]
    trimGprime <- trim_df$Gprime
  }
  else {
    lnGprime <- log(SNPset$Gprime)
    MAD <- median(abs(lnGprime[lnGprime <= median(lnGprime)] -
                        median(lnGprime)))
    trim_df <- SNPset[lnGprime - median(lnGprime) <= 5.2 *
                        median(MAD), ]
    trimGprime <- trim_df$Gprime
  }
  medianTrimGprime <- median(trimGprime)
  modeTrimGprime <- modeest::mlv(x = trimGprime, bw = 0.5,
                                 method = "hsm")[[1]]
  muE <- log(medianTrimGprime)
  varE <- abs(muE - log(modeTrimGprime))
  n <- length(trim_df$Gprime)
  bw <- binwidth
  p <- ggplot2::ggplot(SNPset) + ggplot2::xlim(0, 3*mean(SNPset$Gprime)
                                                 ) + ggplot2::xlab("G' value") + ggplot2::geom_histogram(ggplot2::aes(x = Gprime,
                                                                                                                       fill = "Raw Data"), binwidth = bw) + ggplot2::geom_histogram(data = trim_df,
                                                                                                                                                                                    ggplot2::aes(x = Gprime, fill = "After filtering"), binwidth = bw) +
    ggplot2::stat_function(ggplot2::aes(color = "black"),
                           size = 1, fun = function(x, mean, sd, n, bw) {
                             dlnorm(x = x, mean = muE, sd = sqrt(varE)) *
                               n * bw
                           }, args = c(mean = muE, sd = sqrt(varE), n = n, bw = bw)) +
    ggplot2::scale_fill_discrete(name = "Distribution") +
    ggplot2::scale_colour_manual(name = "Null distribution",
                                 values = "black", labels = as.expression(bquote(~theta["G'"] ~
                                                                                   " ~ lnN(" * .(round(muE, 2)) * "," * .(round(varE,
                                                                                                                                2)) * ")"))) + ggplot2::guides(fill = ggplot2::guide_legend(order = 1,
                                                                                                                                                                                            reverse = TRUE))
  return(p)
}






#' @title obs_MH
#' @param SNPset a data frame with SNPs and genotype fields as imported by
#' @param ChromosomeValue1 Enter a Integer for a specific chromosome i.e. 1,2,..etc.
#' @param ChromosomeValue2 Enter a Integer for a specific chromosome i.e. 1,2,..etc.
#' @param ChromosomeValue3 Enter a Integer for a specific chromosome i.e. 1,2,..etc.
#' @param ChromosomeValue4 Enter a Integer for a specific chromosome i.e. 1,2,..etc.
#' @param threshold Specify Alternate Allelic Frequency threshold
#' @return Plots Alternate Allelic Frequency against GPrime value
#'   \code{\link[modeest]{mlv}} function from the package modeest. Finally, the
#' @export obs_MH





obs_MH<- function(SNPset=NULL, ChromosomeValue1=NULL,ChromosomeValue2=NULL,ChromosomeValue3=NULL,ChromosomeValue4=NULL, threshold=NULL)
{
  frame <- SNPset %>% dplyr::mutate(LowRef = AD_REF.LOW, HighRef = AD_REF.HIGH,
                                    LowAlt = AD_ALT.LOW, HighAlt = AD_ALT.HIGH) %>% select(LowRef,
                                                                                           HighRef, LowAlt, HighAlt)
  p1 <- ((frame$LowAlt)/(frame$LowRef + frame$LowAlt))
  p1 <- round(p1, 3)
  p2 <- ((frame$HighAlt)/(frame$HighRef + frame$HighAlt))
  p2 <- round(p2, 3)
  Chrom <- SNPset %>% select(CHROM)
  POS <- SNPset %>% select(POS)
  AD_High1 <- data.frame(SNPset$AD_ALT.HIGH, SNPset$AD_ALT.LOW)
  AD_High1$AD_High <- paste(AD_High1$SNPset.AD_ALT.HIGH, AD_High1$SNPset.AD_ALT.LOW,
                            sep = ",")
  AD_High <- subset(AD_High1, select = -c(SNPset.AD_ALT.HIGH,
                                          SNPset.AD_ALT.LOW))
  AD_Low1 <- data.frame(SNPset$AD_REF.HIGH, SNPset$AD_REF.LOW)
  AD_Low1$AD_Low <- paste(AD_Low1$SNPset.AD_REF.HIGH, AD_Low1$SNPset.AD_REF.LOW,
                          sep = ",")
  AD_Low <- subset(AD_Low1, select = -c(SNPset.AD_REF.HIGH,
                                        SNPset.AD_REF.LOW))
  Gprime <- SNPset %>% select(Gprime)
  Gprime <- round(Gprime, 3)
  data <- cbind(Chrom, POS, p1, p2, AD_High, AD_Low, Gprime)
  data <- as.data.frame(data)
  data <- data[(as.matrix(data[1]) == ChromosomeValue1) | (as.matrix(data[1]) == ChromosomeValue2) |  (as.matrix(data[1]) == ChromosomeValue3) |  (as.matrix(data[1]) == ChromosomeValue4), ]
  data <- data[(as.matrix(data[4]) > threshold), ]
  e3<-ggscatter(data, x="p2", y="Gprime",color="CHROM",palette = "npg",ellipse = TRUE,mean.point = TRUE,star.plot = TRUE,ggtheme = theme_minimal())
  e3 + stat_cor(method = "pearson",label.x = 1.2,label.y = -100)
  print(e3)
  e4 <- ggscatterhist(data, x = "p2", y = "Gprime",color = "CHROM", palette = c("#00AFBB","#E7B800","#FC4E07","#E79900"),margin.params = list(fill="CHROM",color = "black",size=0.2))
  print(e4)
  e5 <- ggscatter(data, x = "p2", y = "Gprime", color = "CHROM", add = "reg.line",conf.int = TRUE,add.params = list(fill="CHROM"),ggtheme = theme_minimal())
  e5 <- e5 + stat_cor(method = "pearson",label.x = .5,label.y = 6)
  print(e5)
}




#' Plots different paramaters for QTL identification
#'
#' A wrapper for ggplot to plot genome wide distribution of parameters used to
#' identify QTL.
#'
#' @param SNPset a data frame with SNPs and genotype fields as imported by
#'   \code{ImportFromGATK} and after running \code{runGprimeAnalysis} or \code{runQTLseqAnalysis}
#' @param subset a vector of chromosome names for use in quick plotting of
#'   chromosomes of interest. Defaults to
#'   NULL and will plot all chromosomes in the SNPset
#' @param var character. The paramater for plotting. Must be one of: "nSNPs",
#'   "deltaSNP", "Gprime", "negLog10Pval" "diff"
#' @param scaleChroms boolean. if TRUE (default) then chromosome facets will be
#'   scaled to relative chromosome sizes. If FALSE all facets will be equal
#'   sizes. This is basically a convenience argument for setting both scales and
#'   shape as "free_x" in ggplot2::facet_grid.
#' @param line boolean. If TRUE will plot line graph. If FALSE will plot points.
#'   Plotting points will take more time.
#' @param plotThreshold boolean. Should we plot the False Discovery Rate
#'   threshold (FDR). Only plots line if var is "Gprime" or "negLogPval".
#' @param plotIntervals boolean. Whether or not to plot the two-sided Takagi confidence intervals in "deltaSNP" plots.
#' @param q numeric. The q-value to use as the FDR threshold. If too low, no
#'   line will be drawn and a warning will be given.
#' @param ... arguments to pass to ggplot2::geom_line or ggplot2::geom_point for
#'   changing colors etc.
#'
#' @return Plots a ggplot graph for all chromosomes or those requested in
#'   \code{subset}. By setting \code{var} to "nSNPs" the distribution of SNPs
#'   used to calculate G' will be plotted. "deltaSNP" will plot a tri-cube
#'   weighted delta SNP-index for each SNP. "Gprime" will plot the tri-cube
#'   weighted G' value. Setting "negLogPval" will plot the -log10 of the p-value
#'   at each SNP. In "Gprime" and "negLogPval" plots, a genome wide FDR threshold of
#'   q can be drawn by setting "plotThreshold" to TRUE. The defualt is a red
#'   line. If you would like to plot a different line we suggest setting
#'   "plotThreshold" to FALSE and manually adding a line using
#'   ggplot2::geom_hline.
#'
#' @export plotQTLStats_MH


plotQTLStats_MH <-
  function(SNPset,
           subset = NULL,
           var = "nSNPs",
           scaleChroms = TRUE,
           line = TRUE,
           plotThreshold = FALSE,
           plotIntervals = FALSE,
           q = 0.05,
           ...) {

    #get fdr threshold by ordering snps by pval then getting the last pval
    #with a qval < q

    if (!all(subset %in% unique(SNPset$CHROM))) {
      whichnot <-
        paste(subset[base::which(!subset %in% unique(SNPset$CHROM))], collapse = ', ')
      stop(paste0("The following are not true chromosome names: ", whichnot))
    }

    if (!var %in% c("nSNPs", "deltaSNP", "Gprime", "negLog10Pval"))
      stop(
        "Please choose one of the following variables to plot: \"nSNPs\", \"deltaSNP\", \"Gprime\", \"negLog10Pval\""
      )

    #don't plot threshold lines in deltaSNPprime or number of SNPs as they are not relevant
    if ((plotThreshold == TRUE &
         var == "deltaSNP") |
        (plotThreshold == TRUE & var == "nSNPs")) {
      message("FDR threshold is not plotted in deltaSNP or nSNPs plots")
      plotThreshold <- FALSE
    }
    #if you need to plot threshold get the FDR, but check if there are any values that pass fdr

    GprimeT <- 0
    logFdrT <- 0

    if (plotThreshold == TRUE) {
      fdrT <- getFDRThreshold(SNPset$pvalue, alpha = q)
      message("Printing False Discovery Rate")
      print(fdrT)

      if (is.na(fdrT)) {
        warning("The q threshold is too low. No threshold line will be drawn")
        plotThreshold <- FALSE

      } else {
        logFdrT <- -log10(fdrT)
        message("Log Transformation of False Discovery Rate -log10(FalseDiscoveryRate)")
        print(logFdrT)
        GprimeT <- SNPset[which(SNPset$pvalue == fdrT), "Gprime"]
      }
    }

    SNPset <-
      if (is.null(subset)) {
        SNPset
      } else {
        SNPset[SNPset$CHROM %in% subset,]
      }

    p <- ggplot2::ggplot(data = SNPset) +
      ggplot2::scale_x_continuous(breaks = seq(from = 0,to = max(SNPset$POS), by = 10^(floor(log10(max(SNPset$POS))))), labels = format_genomic(), name = "Genomic Position (Mb)") +
      ggplot2::theme(plot.margin = ggplot2::margin(
        b = 10,
        l = 20,
        r = 20,
        unit = "pt"
      ))

    if (var == "Gprime") {
      threshold <- GprimeT
      message("Printing threshold")
      print(threshold)
      p <- p + ggplot2::ylab("G' value")
    }

    if (var == "negLog10Pval") {
      threshold <- logFdrT
      p <-
        p + ggplot2::ylab(expression("-" * log[10] * '(p-value)'))
    }

    if (var == "nSNPs") {
      p <- p + ggplot2::ylab("Number of SNPs in window")
    }

    if (var == "deltaSNP") {
      var <- "tricubeDeltaSNP"
      p <-
        p + ggplot2::ylab(expression(Delta * '(SNP-index)')) +
        ggplot2::ylim(-0.55, 0.55) +
        ggplot2::geom_hline(yintercept = 0,
                            color = "black",
                            alpha = 0.4)
    
      if (plotIntervals == TRUE) {

        ints_df <-
          dplyr::select(SNPset, CHROM, POS, dplyr::matches("CI_")) %>% tidyr::gather(key = "Interval", value = "value",-CHROM,-POS)

        p <- p + ggplot2::geom_line(data = ints_df, ggplot2::aes(x = POS, y = value, color = Interval)) +
          ggplot2::geom_line(data = ints_df, ggplot2::aes(
            x = POS,
            y = -value,
            color = Interval
          ))
      }
    }

    if (line) {
      p <-
        p + ggplot2::geom_line(ggplot2::aes_string(x = "POS", y = var), ...)
    }

    if (!line) {
      p <-
        p + ggplot2::geom_point(ggplot2::aes_string(x = "POS", y = var), ...)
    }

    if (plotThreshold == TRUE)
      p <-
      p + ggplot2::geom_hline(
        ggplot2::aes_string(yintercept = "threshold"),
        color = "red",
        size = 1,
        alpha = 0.4
      )

    if (scaleChroms == TRUE) {
      p <- p + ggplot2::facet_grid(~ CHROM, scales = "free_x", space = "free_x")
    } else {
      p <- p + ggplot2::facet_grid(~ CHROM, scales = "free_x")
    }
    p

  }




#' Plots different paramaters for QTL identification
#'
#' A wrapper for ggplot to plot genome wide distribution of parameters used to
#' identify QTL.
#'
#' @param SNPset a data frame with SNPs and genotype fields as imported by
#'   \code{ImportFromGATK} and after running \code{runGprimeAnalysis} or \code{runQTLseqAnalysis}
#' @param subset a vector of chromosome names for use in quick plotting of
#'   chromosomes of interest. Defaults to
#'   NULL and will plot all chromosomes in the SNPset
#' @param var character. "diff"
#' @param scaleChroms boolean. if TRUE (default) then chromosome facets will be
#'   scaled to relative chromosome sizes. If FALSE all facets will be equal
#'   sizes. This is basically a convenience argument for setting both scales and
#'   shape as "free_x" in ggplot2::facet_grid.
#' @param line boolean. If TRUE will plot line graph. If FALSE will plot points.
#'   Plotting points will take more time.
#' @param ... arguments to pass to ggplot2::geom_line or ggplot2::geom_point for
#'   changing colors etc.
#'
#' @return Plots a ggplot graph for all chromosomes or those requested in
#'   \code{subset}. By setting \code{var} to "nSNPs" the distribution of SNPs
#'   used to calculate G' will be plotted. "deltaSNP" will plot a tri-cube
#'   weighted delta SNP-index for each SNP. "Gprime" will plot the tri-cube
#'   weighted G' value. Setting "negLogPval" will plot the -log10 of the p-value
#'   at each SNP. In "Gprime" and "negLogPval" plots, a genome wide FDR threshold of
#'   q can be drawn by setting "plotThreshold" to TRUE. The defualt is a red
#'   line. If you would like to plot a different line we suggest setting
#'   "plotThreshold" to FALSE and manually adding a line using
#'   ggplot2::geom_hline.
#'
#' @export plotQTLStats_MH2


plotQTLStats_MH2 <-
  function(SNPset,
           subset = NULL,
           var = "diff",
           scaleChroms = TRUE,
           line = TRUE,
           ...) {

    #get fdr threshold by ordering snps by pval then getting the last pval
    #with a qval < q

    if (!all(subset %in% unique(SNPset$CHROM))) {
      whichnot <-
        paste(subset[base::which(!subset %in% unique(SNPset$CHROM))], collapse = ', ')
      stop(paste0("The following are not true chromosome names: ", whichnot))
    }

    if (!var %in% c("diff"))
      stop(
        "Please choose one of the following variable to plot: \"diff\""
      )

    SNPset <-
      if (is.null(subset)) {
        SNPset
      } else {
        SNPset[SNPset$CHROM %in% subset,]
      }

    p <- ggplot2::ggplot(data = SNPset) +
      ggplot2::scale_x_continuous(breaks = seq(from = 0,to = max(SNPset$POS), by = 10^(floor(log10(max(SNPset$POS))))), labels = format_genomic(), name = "Genomic Position (Mb)") +
      ggplot2::theme(plot.margin = ggplot2::margin(
        b = 10,
        l = 20,
        r = 20,
        unit = "pt"
      ))

    if (var == "diff"){
      p <- p + ggplot2::ylab("Difference Between High and Low Bulk Allele Frequencies")
    }

    if (line) {
      p <-
        p + ggplot2::geom_line(ggplot2::aes_string(x = "POS", y = var), ...)
    }

    if (!line) {
      p <- p + ggplot2::geom_point(ggplot2::aes_string(x = "POS", y = var, size = "nSNPs"), ...)
      p
    }

    if (scaleChroms == TRUE) {
      p <- p + ggplot2::facet_grid(~ CHROM, scales = "free_x", space = "free_x")
    } else {
      p <- p + ggplot2::facet_grid(~ CHROM, scales = "free_x")
    }
    p

  }



#' @title Correlation
#' @description Returns a Correlation Matrix for info fields AC, DP, DPB, QA, RO, AO and most importantly QUAL
#' @param vcffile A vcf file
#' @param chromlist A vector of chromosomes/contigs as specified in VCF file
#' @param p1 A boolean Value either TRUE or FALSE for plotting Correlation matrix and Correlation Tables
#' @param p2 A boolean Value either TRUE or FALSE for plotting Correlation matrix and Correlation Tables
#' @param p3 A boolean Value either TRUE or FALSE for plotting Correlation matrix and Correlation Tables
#' @param p4 A boolean Value either TRUE or FALSE for plotting Correlation matrix and Correlation Tables
#' @param p5 A boolean Value either TRUE or FALSE
#' @export Correlation


Correlation <-
  function (vcffile = NULL, chromlist = NULL,p1 = NULL, p2 = NULL, p3 = NULL, p4 = NULL,p5=TRUE)
  {
vcf <- read.vcfR(file = vcffile)
vcf <- vcfR2tidy(vcf)
message("Extracting unique Chromosome or Contig names reverse compatible to VCF file")
print(unique(vcf$fix$CHROM))
SNPset <- vcf
SNPset <- Map(as.data.frame, SNPset)
SNPset <- rbindlist(SNPset, fill = TRUE)
    if (!is.null(chromlist)) {
      message("Preparing Data for Quality Control Plotting: ",
              paste(unique(SNPset$CHROM)[!unique(SNPset$CHROM) %in%
                                           chromlist], collapse = ", "))
      SNPset <- SNPset[SNPset$CHROM %in% chromlist,]
      message("Finishing Chromosome Subset")
}

message("Factoring Chromosome Variable According to Unique Specification")
SNPset$CHROM <- factor(SNPset$CHROM, levels = gtools::mixedsort(unique(SNPset$CHROM)))

message("Selecting Variable Subset")
SNPset <- SNPset %>% select(QUAL,AC,DP,DPB,QA,RO,AO)
SNPset <- as.data.frame(sapply(SNPset, as.numeric))
message("Mutating SNPS set creating nSNPs variable")
p1 <- p1
  if (p1 == TRUE){
    t2 <- cor(SNPset)
      round(t2,2)
      print(t2)
}else if (p1 == FALSE){
        print("Do not plot cor(SNPset)")
}
p2 <- p2
  if (p2 == TRUE){
    t3 <- rcorr(as.matrix(SNPset))
      print(t3)
}else if (p2 == FALSE){
  print("Do not plot rcorr(as.matrix(SNPset))")
}
p3 <- p3
  if (p3 == TRUE){
    t4 <- corrplot(cor(SNPset))
      print(t4)
}else if (p3 == FALSE){
  print("Do not plot corrplot(cor(SNPset))")
}
p4 <- p4
  if (p4 == TRUE){
    t5 <- chart.Correlation(SNPset,histogram=TRUE,pch=19)
      print(t5)
}else if (p4 == FALSE){
  print("Do not plot chart.Correlation(SNPset,histogram=TRUE,pch=19)")
}
p5 <- p5
  if (p5 == TRUE){
    col <- colorRampPalette(c("blue","white","red","purple"))(20)
    t2 <- cor(SNPset)
    heatmap(t2,col=col,symm=TRUE)
}else if (p5 == FALSE){
  print("Do not plot heatmap")
}
    message("Returning completed Data frame as a SNPSet")
    return(as.data.frame(SNPset))
}


#' Plots Gprime distribution
#'
#' Plots a ggplot histogram of the distribution of Gprime with a log normal
#' distribution overlay
#'
#' @param SNPset a data frame with SNPs and genotype fields as imported by
#'   \code{ImportFromGATK} and after running \code{GetPrimeStats}
#' @param outlierFilter one of either "deltaSNP" or "Hampel". Method for
#'   filtering outlier (ie QTL) regions for p-value estimation
#' @param filterThreshold The absolute delta SNP index to use to filter out
#'   putative QTL (default = 0.1)
#' @param binwidth The binwidth for the histogram. Recomended and default = 0.5
#'
#' @return Plots a ggplot histogram of the G' value distribution. The raw data
#'   as well as the filtered G' values (excluding putatitve QTL) are plotted. It
#'   will then overlay an estimated log normal distribution with the same mean
#'   and variance as the null G' distribution. This will allow to verify if
#'   after filtering your G' value appear to be close to log normally and thus
#'   can be used to estimate p-values using the non-parametric estimation method
#'   described in Magwene et al. (2011). Breifly, using the natural log of
#'   Gprime a median absolute deviation (MAD) is calculated. The Gprime set is
#'   trimmed to exclude outlier regions (i.e. QTL) based on Hampel's rule. An
#'   estimation of the mode of the trimmed set is calculated using the
#'   \code{\link[modeest]{mlv}} function from the package modeest. Finally, the
#'   mean and variance of the set are estimated using the median and mode are
#'   estimated and used to plot the log normal distribution.
#'
#'
#' @seealso \code{\link{getPvals}} for how p-values are calculated.
#' @export plotGprimeDist_MH


plotGprimeDist_MH <-
  function(SNPset,
           outlierFilter = c("deltaSNP", "Hampel"),
           filterThreshold = 0.1,
           binwidth = 0.5)
  {
    if (outlierFilter == "deltaSNP") {
      trim_df <- SNPset[abs(SNPset$deltaSNP) < filterThreshold, ]
      trimGprime <- trim_df$Gprime
    } else {
      # Non-parametric estimation of the null distribution of G'

      lnGprime <- log(SNPset$Gprime)

      # calculate left median absolute deviation for the trimmed G' prime set
      MAD <-
        median(abs(lnGprime[lnGprime <= median(lnGprime)] - median(lnGprime)))

      # Trim the G prime set to exclude outlier regions (i.e. QTL) using Hampel's rule
      trim_df <-
        SNPset[lnGprime - median(lnGprime) <= 5.2 * median(MAD),]
      trimGprime <- trim_df$Gprime
    }
    medianTrimGprime <- median(trimGprime)

    # estimate the mode of the trimmed G' prime set using the half-sample method
    modeTrimGprime <-
      modeest::mlv(x = trimGprime, bw = 0.5, method = "hsm")[[1]]

    muE <- log(medianTrimGprime)
    varE <- abs(muE - log(modeTrimGprime))

    n <- length(trim_df$Gprime)
    bw <- binwidth

    #plot Gprime distrubtion
    p <- ggplot2::ggplot(SNPset) +
      ggplot2::xlim(0, 30) +
      ggplot2::xlab("G' value") +
      ggplot2::geom_histogram(ggplot2::aes(x = Gprime, fill = "Raw Data"), binwidth = bw) +
      ggplot2::geom_histogram(data = trim_df,
                              ggplot2::aes(x = Gprime, fill = "After filtering"),
                              binwidth = bw) +
      ggplot2::stat_function(
        ggplot2::aes(color = "black"),
        size = 1,
        fun = function(x, mean, sd, n, bw) {
          dlnorm(x = x,
                 mean = muE,
                 sd = sqrt(varE)) * n * bw
        },
        args = c(
          mean = muE,
          sd = sqrt(varE),
          n = n,
          bw = bw
        )
      ) +

      # ggplot2::stat_function(
      #     fun = dlnorm * n,
      #     size = 1,
      #     args = c(meanlog = muE, sdlog = sqrt(varE)),
      # ggplot2::aes(
      #     color = paste0(
      #         "Null distribution \n G' ~ lnN(",
      #         round(muE, 2),
      #         ",",
      #         round(varE, 2),
    #         ")"
    #     )
    #     )
    # ) +
    ggplot2::scale_fill_discrete(name = "Distribution") +
      ggplot2::scale_colour_manual(name = "Null distribution" , values = "black", labels = as.expression(bquote(~theta["G'"]~" ~ lnN("*.(round(muE, 2))*","*.(round(varE, 2))*")")))  +
      ggplot2::guides(fill = ggplot2::guide_legend(order = 1, reverse = TRUE))

    #ggplot2::annotate(x = 10, y = 0.325, geom="text",
    #    label = paste0("G' ~ lnN(", round(muE, 2), ",",round(varE, 2), ")"),
    #    color = "blue")
    return(p)
  }








#' @title Facet_Allelic_Chrom
#' @description Provides plot of Alterante allelic depths for High and Low Bulk, sorry no sliding window.
#' @param SNPset A vcf file that has been imported by ImportVCF, filtered by SNPfilter, and run
#' @param subset A Chromosome subset
#' @param var This is a variable that you cannot change, it must be defined as Allelicfreq
#' @param scaleChroms TRUE or FASLE do you want plots on each Chromosome or NOT
#' @param line TRUE or FALSE do you want a line graph or just points
#' @param thresholdGprime Gprime Statistic cut off value
#' @param thresholdHighAlternateFrequency High Bulk Alternative Allele Frequency
#' @export Facet_Allelic_Chrom

Facet_Allelic_Chrom <- function(SNPset, subset = NULL, var = "Allelicfreq", scaleChroms = TRUE, line = TRUE, thresholdGprime = NULL, thresholdHighAlternateFrequency = NULL) {
  if (!all(subset %in% unique(SNPset$CHROM))) {
    whichnot <- paste(subset[base::which(!subset %in% unique(SNPset$CHROM))], 
                      collapse = ", ")
    stop(paste0("The following are not true chromosome names: ", whichnot))
  }
  if (!var %in% c("Allelicfreq"))
    stop("Please choose one of the following variables to plot: \"Allelicfreq\"")
  
  SNPset <- if (is.null(subset)) {
    SNPset
  }
  else {
    SNPset[SNPset$CHROM %in% subset, ]
  }
  
  # FIlter for high G' values
  
  SNPset <- SNPset %>% dplyr::select(CHROM, POS, AD_ALT.LOW, AD_ALT.HIGH,Gprime,AD_REF.LOW,AD_REF.HIGH,DP.LOW,DP.HIGH,nSNPs)
  SNPset <- as.data.frame(SNPset)
  SNPset <- SNPset[(as.matrix(SNPset[5]) > thresholdGprime), ]

  
  # Mutate Snpset
  
  SNPset <- SNPset %>% dplyr::mutate(LowRef = AD_REF.LOW, HighRef = AD_REF.HIGH, LowAlt = AD_ALT.LOW, HighAlt = AD_ALT.HIGH) %>% dplyr::select(CHROM, POS, DP.LOW, DP.HIGH, LowRef, HighRef, LowAlt, HighAlt, nSNPs)
  SNPset <- SNPset %>% mutate(LowAlt = as.numeric(LowAlt), DP.LOW = as.numeric(DP.LOW),HighAlt = as.numeric(HighAlt), DP.HIGH = as.numeric(DP.HIGH))
  SNPset <- SNPset %>% mutate(LowFreq = LowAlt/DP.LOW, HighFreq = HighAlt/DP.HIGH)
  SNPset <- SNPset[(as.matrix(SNPset[11]) > thresholdHighAlternateFrequency), ]
  
  # Plotting
  
  p <- ggplot2::ggplot(data = SNPset) + ggplot2::scale_x_continuous(breaks = seq(from = 0, to = max(SNPset$POS), by = 10^(floor(log10(max(SNPset$POS))))), labels = format_genomic(), name = "Genomic Position (Mb)") + ggplot2::theme(plot.margin = ggplot2::margin(b = 10,l = 20, r = 20, unit = "pt"))
  
  p <- p + ggplot2::ylab("High and Low Bulk Allelic Frequencies")
  
  if (line) {
    p <- p + ggplot2::geom_line(ggplot2::aes_string(x = "POS", y = "LowFreq"), color="orange") + ggplot2::geom_line(ggplot2::aes_string(x = "POS", y = "HighFreq" ),color="blue") 
  }
  if (!line) {
    p <- p + ggplot2::geom_point(ggplot2::aes_string(x = "POS", y = "LowFreq"), color="orange") + ggplot2::geom_smooth(ggplot2::aes_string(x = "POS", y = "LowFreq"),se = T, method = 'loess', show.legend = TRUE) + ggplot2::geom_point(ggplot2::aes_string(x = "POS", y = "HighFreq"),color="blue") + ggplot2::geom_smooth(ggplot2::aes_string(x = "POS", y = "HighFreq"),se = T, method = 'loess', show.legend = TRUE)
  }
  if (scaleChroms == TRUE) {
    p <- p + ggplot2::facet_grid(~CHROM, scales = "free_x", space = "free_x")
  }
  else {
    p <- p + ggplot2::facet_grid(~CHROM, scales = "free_x")
  }
  print(p)
  
  return(SNPset)
}

#' @title ChromQual
#' @param vcf A vcf file 
#' @param chromlist A vector specifying particular chromosomes
#' @param windowSize Specify window size to calculate number of SNPs
#' @param ncol An Integer Value Specifying the number of columns in ggplot facet_grid which corresponds to exact number of chromosomes in chromlist
#' @param HighLimQuality Set Upper Limit for Quality 
#' @param p1 TRUE or FALSE to plot or not to plot
#' @param p2 TRUE or FALSE to plot or not to plot
#' @param p3 TRUE or FALSE to plot or not to plot
#' @param p4 TRUE or FALSE to plot or not to plot
#' @param p5 TRUE or FALSE to plot or not to plot
#' @param p6 TRUE or FALSE Boolean Argument, to plot or not to plot that is the question
#' @param p7 TRUE or FALSE to plot or not
#' @return Several ggplots
#' @examples ChromQuality(vcf = "General.vcf", chromlist = c("Chr1", "Chr2")), windowSize = 1e+06, scalar = 0.1, ncol = 2,HighLimQuality = 6000,  binwidth1 = 100, binwidth2 =1, DPBINS=10, p1=TRUE, p2=FALSE, p3=TRUE, p4=TRUE, p5=FALSE, p6=TRUE)
#' @export ChromQual


ChromQual <- 
  function (vcf, chromlist = NULL, windowSize = NULL, ncol = NULL, HighLimQuality = NULL, Chromname= NULL,p1 = NULL, p2 = NULL, p3 = NULL, p4 = NULL, p5 = NULL, p6 = NULL, p7 = NULL) 
  {
    message("Reading vcf file in with read.vcfR")
    vcf <- read.vcfR(file = vcf)
    message("Converting vcf object to tidy data frame with vcfR2tidy")
    vcf <- vcfR2tidy(vcf)
    message("Extracting unique Chromosome or Contig names reverse compatible to VCF file")
    print(unique(vcf$fix$CHROM))
    SNPset <- vcf
    SNPset <- Map(as.data.frame, SNPset)
    SNPset <- rbindlist(SNPset, fill = TRUE)
    if (!is.null(chromlist)) {
      message("Preparing Data for Quality Control Plotting and removing the following Chromosomes/Contigs: ", 
              paste(unique(SNPset$CHROM)[!unique(SNPset$CHROM) %in% 
                                           chromlist], collapse = ", "))
      SNPset <- SNPset[SNPset$CHROM %in% chromlist, ]
      message("Finishing Chromosome Subset")
    }
    message("Factoring Chromosome Variable According to Unique Specification")
    SNPset$CHROM <- factor(SNPset$CHROM, levels = gtools::mixedsort(unique(SNPset$CHROM)))
    message("Selecting Variable Subset")
    SNPset <- SNPset %>% dplyr::select(CHROM, POS, QUAL, DP)
    message("Mutating SNPS set creating nSNPs variable")
    SNPset <- SNPset %>% dplyr::group_by(CHROM) %>% dplyr::mutate(nSNPs = countSNPs_cpp(POS = POS, windowSize = windowSize)) %>% dplyr::filter(QUAL >= HighLimQuality)
    SNPset <- as.data.frame(SNPset)
    SNPset <- SNPset %>% mutate(POS = as.numeric(POS), DP = as.numeric(DP), nSNPs = as.numeric(nSNPs))
    
    
    par(mfrow = c(1, 1))
    p1 <- p1
    if (p1 == TRUE) {
      message("Plotting Quality Scores")
      breaks <- pretty(range(SNPset$QUAL), n = nclass.Sturges(SNPset$QUAL), min.n = 1)
      p <- ggplot(SNPset, aes(QUAL)) + ggplot2::geom_histogram(color = 1, fill = "lightblue", breaks = breaks) + theme_classic() + ggtitle("Sturges Method Histogram of SNP Quality")
      print(p)
      p1 <- ggplot(SNPset, aes(QUAL)) + ggplot2::geom_histogram(color = 1, fill = "lightblue", breaks = breaks) + ggplot2::facet_wrap(~CHROM, ncol = ncol) + theme_classic() + ggplot2::ggtitle("Quality Histogram")
      print(p1)
    }
    else if (p1 == FALSE) {
      print("Do not plot Histogram of Quality Score")
    }
    
    p2 <- p2
    if (p2 == TRUE) {
      message("Plotting Number of SNPs per Chromosome with loess smoothing curve")
     
      p<-ggplot(data = SNPset, aes(x = POS)) + geom_point(aes(y = nSNPs), color = "lightblue") + facet_wrap(~CHROM, ncol = ncol) + theme_bw() + labs(x = "Position on Chromosome", y = "nSNPs", color = "Legend")
      print(p)
    }
    else if (p2 == FALSE) {
      print("Do not plot Superpostion of Quality Scores and Number of SNPs")
    }
    
    p3 <- p3
    if (p3 == TRUE) {
      message("Ploting histogram of SNPs per Chromosome")
      breaks <- pretty(range(SNPset$nSNPs), n = nclass.Sturges(SNPset$nSNPs), min.n = 1)
      p3 <- ggplot(SNPset, aes(nSNPs)) + ggplot2::geom_histogram(color = 1, fill = "lightblue", breaks = breaks) + theme_classic() + ggtitle("Sturges Method Histogram of nSNPs")
      print(p3)
      
      p<-ggplot(data = SNPset, aes(x = nSNPs)) + geom_histogram(color = 1 ,fill = "lightblue", breaks = breaks) + ggplot2::facet_wrap(~CHROM, ncol = ncol) + theme_classic() + ggplot2::ggtitle("nSNPs")
      print(p)
    }
    else if (p3 == FALSE) {
      print("Do not plot Hisotogram of Number of SNPs per Chromosome")
    }
    p4 <- p4
    if (p4 == TRUE) {
      message("Plotting Depth")
      breaks <- pretty(range(SNPset$DP), n = nclass.Sturges(SNPset$DP), min.n = 1)
      p1<-ggplot(data = SNPset, aes(x = DP)) + ggplot2::geom_histogram(color = 1, fill = "lightblue", breaks = breaks) + theme_classic() + ggtitle("Sturges Method Histogram of Depth")
      print(p1)
      p2<-ggplot(data = SNPset, aes(x = DP)) + geom_histogram(color = 1, fill = "lightblue", breaks = breaks) + facet_wrap(~CHROM, ncol = ncol) + theme_classic() + ggtitle("DP")
      print(p2)
      p3<-ggplot(data = SNPset, aes(x = POS)) + geom_point(aes(y = DP), color = "lightblue") + facet_wrap(~CHROM, ncol = ncol) + theme_classic() + ggtitle("DP")
      print(p3)
    }
    else if (p4 == FALSE) {
      print("Do not plot Histogram of Depth Reads")
    }
    
    p5 <- p5
    if (p5 == TRUE) {
      message("Plotting Number of SNPs per Chromosome with loess smoothing curve")
      p<-ggplot(data = SNPset, aes(x = POS)) + geom_point(aes(y = QUAL), color = "lightgreen") + facet_wrap(~CHROM, ncol = ncol) + geom_smooth(aes(y = QUAL)) + theme_bw() + labs(x = "Position on Chromosome", y = "Quality", color = "Legend") 
      print(p)
    }
    else if (p5 == FALSE){
      print("Do not print Number of SNPs per Chromosome with loess smoothing cureve")
    }
    
    p6 <- p6
    if (p6 == TRUE){
      message("Plotting ggridges object")
      p1<-ggplot(data = SNPset, aes(x = QUAL, y = CHROM)) + ggridges::geom_density_ridges2() + theme_ridges() 
      print(p1)
      p2<-ggplot(data = SNPset, aes(x = POS, y = CHROM)) + ggridges::geom_density_ridges2() + theme_ridges() 
      print(p2)
      p3<-ggplot(data = SNPset, aes(x = DP, y = CHROM)) + ggridges::geom_density_ridges2() + theme_ridges() 
      print(p3)
      p4<-ggplot(data = SNPset, aes(x = nSNPs, y = CHROM)) + ggridges::geom_density_ridges2() + theme_ridges() 
      print(p4)
      }
    else if ( p6 == FALSE){
      print("Do not plot ggridges")
    }
    
    
    SNPset <- SNPset %>% mutate(QUAL = scale(QUAL), DP = scale(DP))
    
    p8 <- p7
    if (p7 == TRUE) {
      message("Plotting Number of SNPs per Chromosome with loess smoothing curve")
      p<-ggplot(data = SNPset, aes(x = POS)) + geom_point(aes(y = DP, size = nSNPs),color="pink") + geom_point(aes(y = QUAL),col="lightblue") + facet_wrap(~CHROM, ncol = ncol) + geom_smooth(aes(y = QUAL+DP)) + theme_bw() + labs(x = "Position on Chromosome", y = "Sum of Scaled Counts of nSNPs and Scaled Quality Scores", color = "Legend") + scale_color_manual(values = colors)
      print(p)
      p1<-ggplot(data = SNPset, aes(x = POS)) + geom_point(aes(y = DP, size = nSNPs),color="pink") + geom_line(aes(y = QUAL),col="lightblue") + facet_wrap(~CHROM, ncol = ncol) + geom_smooth(aes(y = QUAL+DP)) + theme_bw() + labs(x = "Position on Chromosome", y = "Sum of Scaled Counts of nSNPs and Scaled Quality Scores", color = "Legend") + scale_color_manual(values = colors)
      print(p1)
    }
    else if (p7 == FALSE) {
      print("Do not plot Mumber of SNPs per Chromosome with loess smoothing curve")
    }
  }




#' @title AlleleFreqSlidingWindow
#' @param vcf A vcf file 
#' @param chromlist A vector specifying particular chromosomes
#' @param windowSize Specify window size to calculate number of SNPs and Tricube Stat Window Size
#' @param highBulk Specify sample name from vcf of the high Bulk
#' @param lowBulk Specify sample name from vcf of the lowBulk
#' @param filename Specify the file name used in nested importFromVCF function
#' @param threshold p2 -p1 > threshold, Difference between Alternate Allelic Frequency in High Bulk and Alternate Allelic Frequency in Low Bulk
#' @export AlleleFreqSlidingWindow



AlleleFreqSlidingWindow <- function (vcf = NULL, chromList = NULL, windowSize = NULL, highBulk = NULL, lowBulk = NULL, filename = NULL, threshold = NULL) {
  
  
  QTLseqr::importFromVCF(file = vcf, highBulk = highBulk, lowBulk = lowBulk, chromList = chromList, filter = FALSE,filename = filename)
 
  
  df <-
    importFromTable(
      file = paste0(filename,".csv"),
      highBulk = highBulk,
      lowBulk = lowBulk,
      chromList = chromList,
      sep = ","
    ) 
  
  SNPset <- df
  if (!is.null(chromList)) {
    message("Preparing Data for Quality Control Plotting and removing the following Chromosomes/Contigs: ", paste(unique(SNPset$CHROM)[!unique(SNPset$CHROM) %in% chromList], collapse = ", "))
    SNPset <- SNPset[SNPset$CHROM %in% chromList, ]
    message("Finishing Chromosome Subset")
  }
  
  message("Factoring Chromosome Variable According to Unique Specification")
  SNPset$CHROM <- factor(SNPset$CHROM, levels = gtools::mixedsort(unique(SNPset$CHROM)))
  message("Selecting Variable Subset")
  SNPset <- SNPset %>% dplyr::select(CHROM, POS, GQ.LOW, GQ.HIGH, DP.LOW, DP.HIGH, AD_ALT.LOW, AD_ALT.HIGH)
  message("Mutating SNPS set creating nSNPs variable")
  SNPset <- SNPset %>% dplyr::group_by(CHROM) %>% dplyr::mutate(nSNPs = countSNPs_cpp(POS = POS, windowSize = windowSize)) 
  SNPset <- as.data.frame(SNPset)
  SNPset <- SNPset %>% mutate(POS = as.numeric(POS), p1 = AD_ALT.LOW/DP.LOW, p2 = AD_ALT.HIGH/DP.HIGH)
  SNPset <- SNPset %>% dplyr::mutate(p1_mean = tricubeStat(POS = POS, Stat = p1, windowSize))
  SNPset <- SNPset %>% dplyr::mutate(p2_mean = tricubeStat(POS = POS, Stat = p2, windowSize))
  SNPset <- SNPset %>% dplyr::filter(p2 - p1 > threshold)
  
  
  p<-ggplot(data = SNPset, aes(x = POS)) + geom_point(aes(y = p1, size = nSNPs),color="pink") + geom_point(aes(y = p2, size = nSNPs)) + facet_wrap(~CHROM, ncol = 10) + theme_bw() + labs(x = "Position on Chromosome", y = "High Parent Allele Frequencies before Tricube Stat Transformation", color = "Legend") 
  print(p)                                          
  
  p<-ggplot(data = SNPset, aes(x = POS)) + geom_point(aes(y = p1, size = nSNPs),color="pink") + geom_line(aes(y = p1, size = nSNPs),color="pink") + geom_point(aes(y = p2, size = nSNPs),color="blue") + geom_line(aes(y = p2, size = nSNPs),color="blue") + facet_wrap(~CHROM, ncol = 10) + theme_bw() + labs(x = "Position on Chromosome", y = "High Parent Allele Frequencies before Tricube Stat Transormation", color = "Legend") 
  print(p)
  
  p<-ggplot(data = SNPset, aes(x = POS)) + geom_point(aes(y = p1_mean, size = nSNPs),color="pink") + geom_point(aes(y = p2_mean, size = nSNPs)) + facet_wrap(~CHROM, ncol = 10) + theme_bw() + labs(x = "Position on Chromosome", y = "High Parent Allele Frequencies After Tricube Stat Transformation", color = "Legend") 
  print(p)                                          
  
  p<-ggplot(data = SNPset, aes(x = POS)) + geom_point(aes(y = p1_mean, size = nSNPs),color="pink") + geom_line(aes(y = p1_mean, size = nSNPs),color="pink") + geom_point(aes(y = p2_mean, size = nSNPs),color="blue") + geom_line(aes(y = p2_mean, size = nSNPs),color="blue") + facet_wrap(~CHROM, ncol = 10) + theme_bw() + labs(x = "Position on Chromosome", y = "High Parent Allele Frequencies After Tricube Stat Transformation", color = "Legend") 
  print(p)
  
  p<-ggplot(data = SNPset, aes(x = POS)) + geom_point(aes(y = p1),color="pink") + geom_point(aes(y = p2)) + facet_wrap(~CHROM, ncol = 10) + theme_bw() + labs(x = "Position on Chromosome", y = "High Parent Allele Frequencies before Tricube Stat Transformation", color = "Legend") 
  print(p)                                          
  
  p<-ggplot(data = SNPset, aes(x = POS)) + geom_point(aes(y = p1),color="pink") + geom_line(aes(y = p1),color="pink") + geom_point(aes(y = p2),color="blue") + geom_line(aes(y = p2),color="blue") + facet_wrap(~CHROM, ncol = 10) + theme_bw() + labs(x = "Position on Chromosome", y = "High Parent Allele Frequencies before Tricube Stat Transormation", color = "Legend") 
  print(p)
  
  p<-ggplot(data = SNPset, aes(x = POS)) + geom_point(aes(y = p1_mean),color="pink") + geom_point(aes(y = p2_mean)) + facet_wrap(~CHROM, ncol = 10) + theme_bw() + labs(x = "Position on Chromosome", y = "High Parent Allele Frequencies After Tricube Stat Transformation", color = "Legend") 
  print(p)                                          
  
  p<-ggplot(data = SNPset, aes(x = POS)) + geom_point(aes(y = p1_mean),color="pink") + geom_line(aes(y = p1_mean),color="pink") + geom_point(aes(y = p2_mean),color="blue") + geom_line(aes(y = p2_mean),color="blue") + facet_wrap(~CHROM, ncol = 10) + theme_bw() + labs(x = "Position on Chromosome", y = "High Parent Allele Frequencies After Tricube Stat Transformation", color = "Legend") 
  print(p)
  
  return(SNPset)
  m
}

#' Plots different paramaters for QTL identification
#'
#' A wrapper for ggplot to plot genome wide distribution of parameters used to
#' identify QTL.
#'
#' @param SNPset a data frame with SNPs and genotype fields as imported by
#'   \code{ImportFromGATK} and after running \code{runGprimeAnalysis} or \code{runQTLseqAnalysis}
#' @param subset a vector of chromosome names for use in quick plotting of
#'   chromosomes of interest. Defaults to
#'   NULL and will plot all chromosomes in the SNPset
#' @param var character. The paramater for plotting. Must be one of: "nSNPs",
#'   "deltaSNP", "Gprime", "negLog10Pval" "diff"
#' @param line boolean. If TRUE will plot line graph. If FALSE will plot points.
#'   Plotting points will take more time.
#' @param plotThreshold boolean. Should we plot the False Discovery Rate
#'   threshold (FDR). Only plots line if var is "Gprime" or "negLogPval".
#' @param q numeric. The q-value to use as the FDR threshold. If too low, no
#'   line will be drawn and a warning will be given.
#' @param ... arguments to pass to ggplot2::geom_line or ggplot2::geom_point for
#'   changing colors etc.
#'
#' @return Plots a ggplot graph for all chromosomes or those requested in
#'   \code{subset}. By setting \code{var} to "nSNPs" the distribution of SNPs
#'   used to calculate G' will be plotted. "deltaSNP" will plot a tri-cube
#'   weighted delta SNP-index for each SNP. "Gprime" will plot the tri-cube
#'   weighted G' value. Setting "negLogPval" will plot the -log10 of the p-value
#'   at each SNP. In "Gprime" and "negLogPval" plots, a genome wide FDR threshold of
#'   q can be drawn by setting "plotThreshold" to TRUE. The defualt is a red
#'   line. If you would like to plot a different line we suggest setting
#'   "plotThreshold" to FALSE and manually adding a line using
#'   ggplot2::geom_hline.
#'
#' @export plotQTLStats_MH


plotQTLStats_MH <-
  function(SNPset,
           subset = NULL,
           var = "Gprime",
           line = TRUE,
           plotThreshold = FALSE,
           q = 0.05,
           ...) {
    
    #get fdr threshold by ordering snps by pval then getting the last pval
    #with a qval < q
    
    if (!all(subset %in% unique(SNPset$CHROM))) {
      whichnot <-
        paste(subset[base::which(!subset %in% unique(SNPset$CHROM))], collapse = ', ')
      stop(paste0("The following are not true chromosome names: ", whichnot))
    }
    
    if (!var %in% c("Gprime"))
      stop(
        "Please choose one of the following variables to plot: \"Gprime\""
      )
   
    
    GprimeT <- 0
    logFdrT <- 0
    
    if (plotThreshold == TRUE) {
      fdrT <- getFDRThreshold(SNPset$pvalue, alpha = q)
      message("Printing False Discovery Rate")
      print(fdrT)
      
      if (is.na(fdrT)) {
        warning("The q threshold is too low. No threshold line will be drawn")
        plotThreshold <- FALSE
        
      } else {
        logFdrT <- -log10(fdrT)
        message("Log Transformation of False Discovery Rate -log10(FalseDiscoveryRate)")
        print(logFdrT)
        GprimeT <- SNPset[which(SNPset$pvalue == fdrT), "Gprime"]
      }
    }
    
    SNPset <-
      if (is.null(subset)) {
        SNPset
      } else {
        SNPset[SNPset$CHROM %in% subset,]
      }
    SNPset <- SNPset %>% dplyr::filter(Gprime > GprimeT)
    
    p <- ggplot2::ggplot(data = SNPset) +
      ggplot2::scale_x_continuous(breaks = seq(from = 0,to = max(SNPset$POS), by = 10^(floor(log10(max(SNPset$POS))))), labels = format_genomic(), name = "Genomic Position (Mb)") +
      ggplot2::theme(plot.margin = ggplot2::margin(
        b = 10,
        l = 20,
        r = 20,
        unit = "pt"
      ))
    
    if (var == "Gprime") {
      threshold <- GprimeT
      message("Printing threshold")
      print(threshold)
      p <- p + ggplot2::ylab("G' value")
      
    }
    
    if (line) {
      p <-
      p <- p + ggplot2::geom_line(ggplot2::aes_string(x = "POS", y = var), ...)
      p + ggplot2::facet_grid(~CHROM, scales = "free_x", space = "free_x")
    }
    
    if (!line) {
      p <-
      p <- p + ggplot2::geom_point(ggplot2::aes_string(x = "POS", y = var), ...)
      p + ggplot2::facet_grid(~CHROM, scales = "free_x", space = "free_x")
    }
    
    write.csv(SNPset, file = "Significant_G_Prime.csv",sep = ",", row.names = FALSE)   
    p
    
  }

